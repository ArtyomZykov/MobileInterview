# Kotlin

### MustHave
<details>
<summary>[kt-1] В чем преимущества использования котлина?</summary>

Null-безопасность

Классы данных (Data Classes)

Sealed Classes

Object

Lateinit var

Coroutines

Inline fun / val

Функции-расширения

Умные приведения типов

В Kotlin необязательно явно указывать тип переменной
</details>

<details>
<summary>[kt-2] Что такое data class, что дает?</summary>
Компилятор автоматически формирует следующие члены данного класса из свойств, объявленных в основном конструкторе:

- пару функций equals()/hashCode(),

- функцию toString() в форме "User(name=John, age=42)",

- компонентные функции componentN(), которые соответствуют свойствам, в соответствии с порядком их
  объявления,

- функцию copy(), для копирования объекта, что позволит изменить только некоторые его свойств,
  оставив остальные неизменными.

</details>

<details>
<summary>[kt-3] Что такое Sealed class</summary>
Изолированные классы и интерфейсы позволяют выразить ограниченные иерархии классов, которые обеспечивают больший контроль над наследованием. Во время компиляции известны все прямые наследники изолированного класса. Никакие другие наследники не могут появиться после компиляции модуля с изолированным классом. Например, сторонние клиенты не могут расширить ваш изолированный класс в своем коде. Таким образом, каждый экземпляр изолированного класса имеет тип из ограниченного набора, который известен при компиляции этого класса.

Изолированные классы похожи на enum-классы: набор значений enum типа также ограничен, но каждая
enum-константа существует только в единственном экземпляре, в то время как наследник изолированного
класса может иметь несколько экземпляров, которые могут нести в себе какое-то состояние.
</details>

<details>
<summary>[kt-4] Что такое inline функция</summary>
Использование функций высшего порядка влечёт за собой снижение производительности: во-первых, любая функция является объектом, а во-вторых, происходит захват контекста замыканием, то есть функции становятся доступны переменные, объявленные вне её тела. А выделения памяти (как для объекта функции, так и для её класса) и виртуальные вызовы занимают системные ресурсы.

Но во многих случаях эти дополнительные затраты можно устранить с помощью инлайнинга (встраивания)
лямбда-выражений.

Если функция помечена ключевым словом inline, то при компиляции код написаный в ней будет встроен в
место ее использования.
</details>

<details>
<summary>[kt-5] Что такое Extensions(Расширение)</summary>
Kotlin позволяет расширять класс путём добавления нового функционала без необходимости наследования от такого класса и использования паттернов, таких как Decorator. Это реализовано с помощью специальных выражений, называемых расширениями.

Например, вы можете написать новые функции для класса из сторонней библиотеки, которую вы не можете
изменить. Такие функции можно вызывать обычным способом, как если бы они были методами исходного
класса. Этот механизм называется функцией расширения. В функции-расширении разрешено напрямую
обращаться к методам и свойствам расширяемого класса (кроме закрытых или защищённых свойств или
методов). Функцию-расширение нельзя переопределить в подклассах (наследниках). Существуют также
свойства расширения, которые позволяют определять новые свойства для существующих классов.

```kotlin
fun MutableList<Int>.swap(index1: Int, index2: Int) {
    val tmp = this[index1] // 'this' даёт ссылку на список
    this[index1] = this[index2]
    this[index2] = tmp
}
```

</details>

<details>
<summary>[kt-6] Что такое делегаты</summary>
Делегированные свойства позволяют делегировать получение или присвоение их значения во вне - другому классу. Это позволяет нам добавить некоторую дополнительную логику при операции со свойствами, например, логгирование, какую-то предобработку и т.д.

Формальный синтаксис делегированного свойства:

```kotlin
var имя_свойства: тип_данных by выражение
```

После типа данных свойства идет ключевое слово by, после которого указывается выражение. Выражение
представляет класс, который условно называется делегатом. Делегаты свойств могут не применять
никаких интерфейсов, однако они должны предоставлять функции getValue() и setValue(). А выполнение
методов доступа get() и set(), которые есть у свойства, делегируется функциям getValue() и
setValue() класса делегата.

Стоит отметить, что мы не можем объявлять делегированные свойства в первичном конструкторе
</details>

<details>
<summary>[kt-7] Что такое Generics</summary>
Как и в Java, в Kotlin классы могут иметь типовые параметры

```kotlin
class Box<T>(t: T) {
    var value = t
}
```

Для того, чтобы создать объект такого класса, необходимо предоставить тип в качестве аргумента

Обобщённые ограничения

Набор всех возможных типов, которые могут быть переданы в качестве параметра, может быть ограничен с
помощью обобщённых ограничений.

Самый распространённый тип ограничений - верхняя граница, которая соответствует ключевому слову
extends из Java.

```kotlin
fun <T : Comparable<T>> sort(list: List<T>) {
    ...
}
```

Проверки безопасности типов, выполняемые Kotlin для использования общих объявлений, выполняются во
время компиляции. Во время выполнения экземпляры общих типов не содержат никакой информации об их
фактических аргументах типа. Говорят, информация о типе будет удалена. Например, экземпляры Foo<Bar>
и Foo<Baz?> удаляются до Foo<*>.

Поэтому нет общего способа проверить, был ли создан экземпляр общего типа с определенными
аргументами типа во время выполнения, и компилятор запрещает такие is-проверки.
[статья](https://kotlinlang.ru/docs/reference/generics.html)
</details>

### Лишним не будет

<details>
<summary>[kt-8] Что такое Inner class</summary>
Класс, отмеченный как внутренний с помощью слова inner, может иметь доступ к членам внешнего класса. Внутренние классы содержат ссылку на объект внешнего класса.

```kotlin
class Outer {
    private val bar: Int = 1

    inner class Inner {
        fun foo() = bar
    }
}

val demo = Outer().Inner().foo()
```

Экземпляры анонимного внутреннего класса создаются с помощью объектов-выражений

```kotlin
window.addMouseListener(object : MouseAdapter() {

    override fun mouseClicked(e: MouseEvent) {
        ...
    }

    override fun mouseEntered(e: MouseEvent) {
        ...
    }
})
```

</details>

<details>
<summary>[kt-9] Что такое primary и secondary конструкторы?</summary>

Первичный конструктор является частью заголовка класса и определяется сразу после имени класса:

```kotlin
class Person constructor(_name: String) {

}
```

Класс также может определять вторичные конструкторы. Они применяются в основном, чтобы определить
дополнительные параметры, через которые можно передавать данные для инициализации объекта.

Вторичные конструкторы определяются в теле класса. Если для класса определен первичный конструктор,
то вторичный конструктор должен вызывать первичный с помощью ключевого слова this:

```kotlin 
class Person(_name: String){
val name: String = _name
var age: Int = 0

    constructor(_name: String, _age: Int) : this(_name){
        age = _age
    }
}
```

Здесь в классе Person определен первичный конструктор, который принимает значение для установки
свойства name.

И также добавлен вторичный конструктор. Он принимает два параметра: _name и _age. С помощью
ключевого слова this вызывается первичный конструктор, поэтому через этот вызов необходимо передать
значения для параметров первичного конструктора. В частности, в первичный конструктор передается
значение параметра _name. В самом вторичном конструкторе устанавливается значение свойства age.

```kotlin
constructor(_name: String, _age: Int) : this(_name) {
    age = _age
}
```

Таким образом, при вызове вторичного конструктора вначале вызывается первичный конструктор,
срабатывает блок инициализатора, который устанавливает свойство name. Затем выполняются собственно
действия вторичного конструктора, который устанавливает свойство age.
</details>

### Нюансы

<details>
<summary>[kt-10] Ключевое слово reified</summary>

```kotlin
inline fun <reified T> myGenericFun()
```

Ключевое слово reified может быть использовано только с инлайн функцией.

Когда вы вызываете инлайн функции с ключевым словом reified, компилятор знает, для какого именно
класса она вызывается, что дает нам возможность внутри функции обращаться к генерику, как к классу

например

```kotlin
inline fun <reified T : Any> String.toKotlinObject(): T {
    val mapper = jacksonObjectMapper()
    return mapper.readValue(this, T::class.java)
}
```

без ключевого слова reified обращение к `T::class.java` вызовет ошибку

</details>

<details>
<summary>[kt-11] Какие Flow бывают в котлине?</summary>
StateFlow, MutableStateFlow, ShareFlow, MutableShareFlow

StateFlow имеет две разновидности: StateFlow и MutableStateFlow. MutableStateFlow является
наследником StateFlow и позволяет изменять хранящиеся в нем значение

Состояние представлено значением. Любое изменение значения будет отражено во всех коллекторах потока
путем выдачи значения с изменениями состояния.

```kotlin 
public interface StateFlow<out T> : SharedFlow<T> {
   public val value: T
}

public interface MutableStateFlow<out T>: StateFlow<T>, MutableSharedFlow<T> {
   public override var value: T
   public fun compareAndSet(expect: T, update: T): Boolean
}
```

SharedFlow - этот API-интерфейс подходит для обработки ряда выдаваемых значений, например для
вычисления скользящего среднего из потока данных.

```kotlin 
public interface SharedFlow<out T> : Flow<T> {
  public val replayCache: List<T>
}
```

Общий поток — это просто поток, где есть кэш повтора, который можно использовать в качестве
атомарного моментального снимка. Каждый новый подписчик сначала получает значения из кэша повтора, а
затем получает новые выданные значения. Вместе с SharedFlow мы также предоставляется
MutableSharedFlow.

```kotlin
interface MutableSharedFlow<T> : SharedFlow<T>, FlowCollector<T> {
    suspend fun emit(value: T)
    fun tryEmit(value: T): Boolean
    val subscriptionCount: StateFlow<Int>
    fun resetReplayCache()
}
```

С помощью MutableSharedFlow можно выдавать значения из приостанавливающего и неприостанавливающего контекста. Как можно заключить из имени, кэш повтора MutableSharedFlow можно сбрасывать. Кроме того, он предоставляет количество своих коллекторов как поток.
</details>

<details>
<summary>[kt-12] Какой поток горячий: SharedFlow или StateFlow?</summary>
Вопрос с подковыркой. Они оба - горячие

Холодные потоки генерируют события только при наличии подписчиков, горячие потоки могут генерировать новые события, даже если на них не реагируют никакие подписчики.

[Доки](https://developer.android.com/kotlin/flow/stateflow-and-sharedflow)
</details>