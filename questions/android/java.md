# Java


### MustHave

<details>
<summary>[jv-1] Какие типы ссылок есть в Java?</summary>

StrongReference, SoftReference, WeakReference, PhantomReference

По сути, различие между всеми типами ссылок только одно — поведение GC с объектами, на которые они ссылаются.

SoftReference — если GC видит что объект доступен только через цепочку soft-ссылок, то он удалит его из памяти. Потом. Наверно.

WeakReference — если GC видит что объект доступен только через цепочку weak-ссылок, то он удалит его из памяти.

PhantomReference — если GC видит что объект доступен только через цепочку phantom-ссылок, то он его удалит из памяти. После нескольких запусков GC.

Более детально: https://habr.com/ru/post/169883/

</details>

<details>
<summary>[jv-2] Вопрос про работу Garbage Collector. Представим, что существует 3 объекта: А, В и С. А ссылается на B, B ссылается на C, C ссылается на A. Соберет ли сборщик мусора такую цепочку?</summary>

Да, сборщик мусора соберет такую цепочку. "Живыми" могут считаться только те объекты, до которых мы можем добраться посредством цепочки ссылок, начиная с корневой (Garbage Collector Root) - ссылки, непосредственно существующей в выполняемом коде. Если мы представим все объекты и ссылки между ними как дерево, то нам нужно будет пройти с корневых узлов (точек) по всем рёбрам.
При этом узлы, до которых мы сможем добраться - не мусор, все остальные - мусор. Именно поэтому в андроид не возникает проблемы с утечкой памяти при возникновении циклических зависимостей. Объекты А, В и С больше не используются, но каждый из них ссылается на другой. Однако они недостижимы с помощью цепочки сильных ссылок, начинающейся от корневой ссылки сборщика мусора и будут собраны им.

**Garbage Collector Root**

Если мы представим все объекты и ссылки между ними как дерево, то нам нужно будет пройти с корневых узлов (точек) по всем рёбрам. При этом узлы, до которых мы сможем добраться - не мусор, все остальные - мусор. Этот подход получил название “трассировка” (tracing). Существует несколько типов корневых точек:

- Локальные переменные и параметры методов;
- Активные потоки;
- Статические переменные (так как на них ссылаются их классы);
- Application и Context

![image](https://kmm.icerock.dev/assets/images/gc-f1ce86f0b4235f1b4cec861f0007b7b1.jpg)

[Из базы знаний IceRock. Посмотреть...](https://kmm.icerock.dev/learning/memory_management#%D0%BF%D0%BE%D0%B4%D1%85%D0%BE%D0%B4-garbage-collector-%D0%BD%D0%B0-%D0%B0%D0%BD%D0%B4%D1%80%D0%BE%D0%B8%D0%B4/)

</details>

<details>
<summary>[jv-3] Ключевое слово final</summary>
класс, который нельзя расширить, метод, который нельзя переопределить или завершённый член данных;
</details>

<details>
<summary>[jv-4] Ключевое слово synchronized</summary>
Доступ к участку кода только одному потоку;
</details>

### Лишним не будет

<details>
<summary>[jv-5] Исключения в джава и котлин</summary>

![image](https://habrastorage.org/webt/hn/mx/yz/hnmxyzwyfbelfe32oqi1nyite4o.png)

В kotline все ошибки являются непроверяемыми

В java исключения деляться на непроверяемые и проверяемые. Каждая функция должна содержать список всех проверяемых исключений которые могут в ней произойти.

```java
public void method() throws PanicException { }
```
</details>
<details>
<summary>[jv-6] В чём отличия checked/unchecked исключений</summary>

Checked исключения, это те, которые должны обрабатываться блоком catch или описываться в сигнатуре метода. Unchecked могут не обрабатываться и не быть описанными.

Unchecked исключения в Java — наследованные от RuntimeException, checked — от Exception (не включая unchecked).

</details>

<details>
<summary>[jv-7] В чем разница ArrayList и LinkedList</summary>

Преимущества ArrayList: в возможности доступа к произвольному элементу по индексу за постоянное время (так как это массив), минимум накладных расходов при хранении такого списка, вставка в конец списка в среднем производится так же за постоянное время. В среднем потому, что массив имеет определенный начальный размер n (в коде это параметр capacity), по умолчанию n = 10, при записи n+1 элемента, будет создан новый массив размером (n * 3) / 2 + 1, в него будут помещены все элементы из старого массива + новый, добавляемый элемент. В итоге получаем, что при добавлении элемента при необходимости расширения массива, время добавления будет значительно больше, нежели при записи элемента в готовую пустую ячейку. Тем не менее, в среднем время вставки элемента в конец списка является постоянным. Удаление последнего элемента происходит за константное время. Недостатки ArrayList проявляются при вставке/удалении элемента в середине списка — это взывает перезапись всех элементов размещенных «правее» в списке на одну позицию влево, кроме того, при удалении элементов размер массива не уменьшается, до явного вызова метода trimToSize().

LinkedList наоборот, за постоянное время может выполнять вставку/удаление элементов в списке (именно вставку и удаление, поиск позиции вставки и удаления сюда не входит). Доступ к произвольному элементу осуществляется за линейное время (но доступ к первому и последнему элементу списка всегда осуществляется за константное время — ссылки постоянно хранятся на первый и последний, так что добавление элемента в конец списка вовсе не значит, что придется перебирать весь список в поисках последнего элемента). В целом же, LinkedList в абсолютных величинах проигрывает ArrayList и по потребляемой памяти и по скорости выполнения операций. LinkedList предпочтительно применять, когда происходит активная работа (вставка/удаление) с серединой списка или в случаях, когда необходимо гарантированное время добавления элемента в список.</details>

<details>

<summary>[jv-8] Как устроена HashMap</summary>

Вкратце, HashMap состоит из «корзин» (bucket`ов). С технической точки зрения «корзины» — это элементы массива, которые хранят ссылки на списки элементов. При добавлении новой пары ключ-значение, вычисляет хеш-код ключа, на основании которого вычисляется номер корзины (номер ячейки массива), в которую попадет новый элемент. Если корзина пустая, то в нее сохраняется ссылка на вновь добавляемый элемент, если же там уже есть элемент, то происходит последовательный переход по ссылкам между элементами в цепочке, в поисках последнего элемента, от которого и ставится ссылка на вновь добавленный элемент. Если в списке был найден элемент с таким же ключом, то он заменяется. Добавление, поиск и удаление элементов выполняется за константное время. Вроде все здорово, с одной оговоркой, хеш-функций должна равномерно распределять элементы по корзинам, в этом случае временная сложность для этих 3 операций будет не ниже lg N, а в среднем случае как раз константное время.

[статья](https://habr.com/ru/post/128017/)

</details>

<details>
<summary>[jv-9] Ключевое слово volatile</summary>
Поле не будет кешироваться в каждом потоке (т.е. копироваться в Thread local cache)
Нельзя будет одновременно двум потокам получать значение переменной
Поле доступно нескольким потокам;
</details>

<details>
<summary>[jv-10] Ключевое слово native</summary>
метод с кодом, написанным на другом языке;
</details>

### Нюансы

<details>
<summary>[jv-11] Parcelable vs Serializable</summary>

hashCode позволяет определить корзину для поиска элемента, а equals используется для сравнения ключей элементов в списке внутри корзины и искомого ключа.

</details>

<details>
<summary>[jv-12] Роль equals и hashCode в HashMap?</summary>
hashCode позволяет определить корзину для поиска элемента, а equals используется для сравнения ключей элементов в списке внутри корзины и искомого ключа.
</details>

<details>
<summary>[jv-13] В чем разница между хэш мапом и хэш сетом, что такое коллизии</summary>

Разница в том, что хотя HashSet и фактически использует под капотом HashMap но они реализуют разные интерфейсы.

HashMap используется для хранения пар ключ-значение с использованием метода put Пример: hm.put (ключ, значение); а HashSet используется для хранения только уникальных объектов с помощью метода add. Пример: hs.add (object) ;.

HashMap не позволяет дублировать ключи, но значения можно дублировать, а HashSet не разрешает дублирование объектов.

</details>

<details>
<summary>[jv-14] В чем отличия TreeSet и HashSet?</summary>

Начнем с того, что Set — это множество (так же называют «набором»). Set не допускает хранение двух одинаковых элементов. Формально говоря, термин «множество» и так обозначает совокупность различных элементов, очень важно, что именно различных элементов, так как это главное свойство Set. С учетом такого определения, пояснение про хранение одинаковых элементом не требуется, но в обиходе, понятие «множество» потеряло свой строгий смысл касательно уникальности элементов, входящих в него, поэтому все же уточняйте отдельно данное свойство множества.

TreeSet обеспечивает упорядоченно хранение элементов в виде красно-черного дерева. Сложность выполнения основных операций в TreeSet lg N. HashSet использует для хранения элементов такой же подход, что и HashMap, за тем отличием, что в HashSet в качестве ключа выступает сам элемент, кроме того HashSet (как и HashMap) не поддерживает упорядоченное хранение элементов и обеспечивает временную сложность выполнения операций аналогично HashMap.

</details>

<details>
<summary>[jv-15] Как узнать тип дженерика во время выполнения программы</summary>

При работе с дженериками есть одна очень важная особенность, о которой необходимо помнить. Она называется “стирание типов” (type erasure).

Ее суть заключается в том, что внутри класса не хранится никакой информации о его типе-параметре.

Эта информация доступна только на этапе компиляции и стирается (становится недоступной) в runtime.
</details>

<details>
<summary>[jv-16] Как реализованы дженерики внутри?</summary>

Дженерики фактически работают лишь на этапе компиляции. При преобразовании в байт код данные о типе дженерика стираются (type erasure)
</details>
