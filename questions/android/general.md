# Общие вопросы

В этом разделе собраны общие вопросы по программированию, проектированию и архитектуре.

### MustHave

<details>
<summary>[gen-1] Какие существуют основные принципы ООП?</summary>

Базовые принципы ООП:

* Абстракция — отделение концепции от ее экземпляра; под абстракцией понимают выделение главных,
  наиболее значимых характеристик предмета и наоборот — отбрасывание второстепенных, незначительных
  для работы программы характеристик;
* Полиморфизм — реализация задач одной и той же идеи разными способами; возможность работать с
  несколькими типами так, будто это один и тот же тип. При этом поведение объектов будет разным в
  зависимости от типа, к которому они принадлежат;
* Наследование — способность объекта или класса базироваться на другом объекте или классе. Это
  главный механизм для повторного использования кода. Наследственное отношение классов четко
  определяет их иерархию;
* Инкапсуляция — размещение одного объекта или класса внутри другого для разграничения доступа к
  ним.

_Источник: [tproger.ru](https://tproger.ru/translations/oop-principles-cheatsheet/)_

</details>

<details>
<summary>[gen-2] Что такое SOLID (объектно-ориентированное программирование)?</summary>

SOLID (сокр. от англ. single responsibility, open-closed, Liskov substitution, interface segregation
и dependency inversion) в программировании — мнемонический акроним, введённый Майклом Фэзерсом (
Michael Feathers) для первых пяти принципов, названных Робертом Мартином в начале 2000-х, которые
означали пять основных принципов объектно-ориентированного программирования и проектирования.
Принципы SOLID — это руководства, которые также могут применяться во время работы над существующим
программным обеспечением для его улучшения - например для удаления «дурно пахнущего кода».

Избавиться от "признаков плохого проекта" помогают следующие пять принципов SOLID:

* **S** - Принцип единственной ответственности (The Single Responsibility Principle) каждый класс
  выполняет лишь одну задачу.
* **O** - Принцип открытости/закрытости (The Open Closed Principle) «программные сущности должны
  быть открыты для расширения, но закрыты для модификации.»
* **L** - Принцип подстановки Барбары Лисков (The Liskov Substitution Principle) «объекты в
  программе должны быть заменяемыми на экземпляры их подтипов без изменения правильности выполнения
  программы.» Наследующий класс должен дополнять, а не изменять базовый. Должна быть возможность
  работы с любым наследником класса без нарушения поведения системы.
* **I** - Принцип разделения интерфейса (The Interface Segregation Principle) «много интерфейсов,
  специально предназначенных для клиентов, лучше, чем один интерфейс общего назначения.»
* **D** - Принцип инверсии зависимостей (The Dependency Inversion Principle) «Зависимость на
  Абстракциях. Нет зависимости на что-то конкретное.»

_
Источник: [wikipedia.org](https://ru.wikipedia.org/wiki/SOLID_%28%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BD%D0%BE-%D0%BE%D1%80%D0%B8%D0%B5%D0%BD%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%29)_

</details>

<details>
<summary>[gen-3] В чем преимущества clean архитектуры?</summary>
используя чистую архитектуру, ваш код станет:

Многоразовым: хорошо написанный и организованный код можно использовать повторно (даже в других
проектах).

Гибким: рефакторинг и поддержка вашего кода станет проще и потребует мало усилий. Вам не нужно будет
менять код везде, когда вы хотите заменить библиотеку на другую, например, потому что весь код,
отвечающий за взаимодействие непосредственно с этой библиотекой, будет находиться на одном уровне.

Чистым: код становится чистым и простым. Таким образом, если новый разработчик только что попал в
вашу команду, он не будет иметь проблем, пытаясь понять код. А также, годы спустя, когда вы
забудете, что вы сделали в этом коде, вы сможете легко понять его.

Тестируемый: как было сказано ранее, с чистой архитектурой, тестирование кода будет более легкой
задачей, потому что вы сможете обеспечить необходимую изоляцию.

Менее зависимым от технологий, с которыми он был построен: замена базы данных на другую, изменение
фреймворка, выбор другого механизма шаблонов, замена библиотек и т. д. не потребует от вас
перезаписи всего кода. Эти изменения будут сделаны с небольшой корректировкой кода, что позволит
выполнять эти изменения проще и быстрее.

подробнее про саму clean
архитектуру: [ссылка](https://www.fandroid.info/lektsiya-4-po-arhitekture-android-prilozheniya-clean-arcitecture/)
статья на хабре про Clean Architecture: [ссылка](https://habr.com/ru/company/mobileup/blog/335382/)
</details>

### Лишним не будет

<details>
<summary>[gen-4] На каком паттерне основана архитектура MVVM и что из себя представляет?</summary>
</details>

<details>
<summary>[gen-5] Что такое MVC?</summary>
MVP - архитектура Model-View-Presenter

![image](https://images3.russianblogs.com/690/ba/ba68d933ed1d04bd76c669af902b834a.png)
![image](https://images3.russianblogs.com/615/ff/ff85718e7c336788dd4acb57817d86d7.png)

View：Соответствует файлу макета xml // Используется для отображения данных Model：Модель сущности
Controllor：Соответствует бизнес-логике Activity, обработке данных и обработке пользовательского
интерфейса
![image](https://images3.russianblogs.com/674/99/9938e788d0acf004743fc8b317de5722.png]])

Просмотр слоя (Просмотр)
обычно используют файлы XML для описания интерфейса, эти XML можно понимать как AndroidApp View. Его
можно очень удобно вводить при использовании. В то же время более поздний интерфейс удобно
модифицировать. Если идентификатор, соответствующий интерфейсу в логике, не изменяется, код не нужно
изменять, что значительно повышает ремонтопригодность кода.

Уровень управления (Контроллер)
Уровень управления Android в MVC возложен на Activity. Activity изначально использовалась как
страница инициализации для отображения операций с данными, но, поскольку функция представления XML
слишком слабая, Activity отвечает за представление. Кроме того, к дисплею добавляется управляющая
логика, которая берет на себя слишком много функций. Ответственность за уровень управления Android
обычно ложится на плечи многих Activity. Это предложение также подразумевает, что не следует писать
код в Activity, но необходимо передать Activity для обеспечения обработки уровня бизнес-логики
модели. Другой причиной этого является то, что время отклика Actictivity в Android составляет 5 с.
Если здесь размещена трудоемкая операция, Программа легко может быть переработана.

Слой модели (Модель)

Для бизнес-модели мы устанавливаем структуру данных и связанные классы, которые в основном отвечают
за сетевые запросы, обработку базы данных и операции ввода-вывода. Ее можно понимать как Модель
AndroidApp.Модель не связана с представлением, а связана с бизнесом. Работа базы данных, работа сети
и т. Д. Должны обрабатываться в модели, конечно, операция бизнес-расчетов также должна быть помещена
в этот слой.

Из-за слабой функциональности XML-макета в android, Activity берет на себя большую часть работы.
Итак, mvc в большинстве случаев больше похож на эту форму:

![image](https://images4.russianblogs.com/851/f2/f2b72031eb1c5a1529ebaa6408ba31e3.png)
</details>

<details>
<summary>[gen-6] Что такое MVP?</summary>
MVP - архитектура Model-View-Presenter

![image](https://startandroid.ru/images/stories/blog/493/x010.png.pagespeed.ic.QC26kF2Y20.png)

Если рассматривать Activity, которое отображает какие-то данные с сервера, то View - это Activity, а
Model - это ваши классы по работе с сервером. Напрямую View и Model не взаимодействуют. Для этого
используется Presenter.

Если в Activity пользователь нажал кнопку Обновить, то Activity сообщает об этом презентеру. При
этом Activity не просит презентер загрузить данные. Оно просто сообщает, что пользователь нажал
кнопку Обновить. А презентер уже сам решает, что по нажатию этой кнопки надо делать. Он запрашивает
данные у модели и передает их в Activity, чтобы отобразить на экране.

Для взаимодействия view и презентера используется интерфейс, который реализует view и через который
presenter сообщает какие данные нужно отобразить.

</details>
<details>
<summary>[gen-7] Что такое MVVM?</summary>
MVVM - архитектура Model-View-ViewModel

![image](https://miro.medium.com/max/1400/0*qv-M58lX8ou0_qXy.png)

View - Содержит структурное определение того, что пользователи получат на экранах. Вы можете
поместить сюда статическое и динамическое содержимое (анимацию и смену состояний). Тут может не быть
никакой логики приложения. Для нашего случая в представлении может быть активность или фрагмент.

ViewModel - Этот компонент связывает модель и представление. Отвечает за управление ссылками данных
и возможных конверсий. Здесь появляется биндинг. В Android мы не беспокоимся об этом, потому что
можно напрямую использовать класс AndroidViewModel или ViewModel.

Model - Это уровень бизнес-данных и он не связан ни с каким особенным графическим представлением. В
Android, согласно “чистой” архитектуре, модель может содержать базу данных, репозиторий и класс
бизнес-логики. Картинка ниже описывает взаимодействие между разными компонентами

![image](https://miro.medium.com/max/1216/0*XzmkACDIYuXma49c.png)

Разница между MVVM и MVP в методе взамодействя View c представлением. Если в MVP она реализованна
через интерфейс, то в MVVM используется реактивщина.

</details>

### Нюансы

<details>
<summary>[gen-8] Что такое MVI?</summary>
Основная идея MVI лежит в том что все можно представить как поток.

Например кнопка в UI это Observable который может посылать сообщения о своем нажатии, после цепочки
обработок оно должно изменить State экрана, что приведет к изменению ui, который в свою очередь
подписан на State.

</details>