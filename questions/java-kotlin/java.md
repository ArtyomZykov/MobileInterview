# Java

### MustHave

<details>
<summary>[jv-1] Какие типы ссылок есть в Java?</summary>

StrongReference, SoftReference, WeakReference, PhantomReference

По сути, различие между всеми типами ссылок только одно — поведение GC с объектами, на которые они
ссылаются.

SoftReference — если GC видит что объект доступен только через цепочку soft-ссылок, то он удалит его
из памяти. Потом. Наверно.

WeakReference — если GC видит что объект доступен только через цепочку weak-ссылок, то он удалит его
из памяти.

PhantomReference — если GC видит что объект доступен только через цепочку phantom-ссылок, то он его
удалит из памяти. После нескольких запусков GC.

Более детально: https://habr.com/ru/post/169883/

</details>

<details>
<summary>[jv-2] Вопрос про работу Garbage Collector. Представим, что существует 3 объекта: А, В и С. А ссылается на B, B ссылается на C, C ссылается на A. Соберет ли сборщик мусора такую цепочку?</summary>

Да, сборщик мусора соберет такую цепочку. "Живыми" могут считаться только те объекты, до которых мы
можем добраться посредством цепочки ссылок, начиная с корневой (Garbage Collector Root) - ссылки,
непосредственно существующей в выполняемом коде. Если мы представим все объекты и ссылки между ними
как дерево, то нам нужно будет пройти с корневых узлов (точек) по всем рёбрам.
При этом узлы, до которых мы сможем добраться - не мусор, все остальные - мусор. Именно поэтому в
андроид не возникает проблемы с утечкой памяти при возникновении циклических зависимостей. Объекты
А, В и С больше не используются, но каждый из них ссылается на другой. Однако они недостижимы с
помощью цепочки сильных ссылок, начинающейся от корневой ссылки сборщика мусора и будут собраны им.

**Garbage Collector Root**

Если мы представим все объекты и ссылки между ними как дерево, то нам нужно будет пройти с корневых
узлов (точек) по всем рёбрам. При этом узлы, до которых мы сможем добраться - не мусор, все
остальные - мусор. Этот подход получил название “трассировка” (tracing). Существует несколько типов
корневых точек:

- Локальные переменные и параметры методов;
- Активные потоки;
- Статические переменные (так как на них ссылаются их классы);
- Application и Context

![image](https://kmm.icerock.dev/assets/images/gc-f1ce86f0b4235f1b4cec861f0007b7b1.jpg)

[Из базы знаний IceRock. Посмотреть...](https://kmm.icerock.dev/learning/memory_management#%D0%BF%D0%BE%D0%B4%D1%85%D0%BE%D0%B4-garbage-collector-%D0%BD%D0%B0-%D0%B0%D0%BD%D0%B4%D1%80%D0%BE%D0%B8%D0%B4/)

</details>

<details>
<summary>Ключевое слово final</summary>
класс, который нельзя расширить, метод, который нельзя переопределить или завершённый член данных;
</details>

<details>
<summary>Ключевое слово synchronized</summary>
Доступ к участку кода только одному потоку;
</details>

### Лишним не будет

<details>
<summary>Исключения в Java и Kotlin</summary>

![image](https://habrastorage.org/webt/hn/mx/yz/hnmxyzwyfbelfe32oqi1nyite4o.png)

В kotline все ошибки являются непроверяемыми

В java исключения делятся на непроверяемые и проверяемые. Каждая функция должна содержать список
всех проверяемых исключений которые могут в ней произойти.

```java
public void method() throws PanicException {
}
```

<b>Зачем в Java нужно разделение на checked - unchecked, и почему в Kotlin от этого разделения
вообще
отказались:</b>

Почему разделение на checked и unchecked?

Разделение позволяет управлять потенциальными ошибками, которые могут быть исправлены, и отличать их
от ошибок времени выполнения, которые чаще всего являются результатом ошибок в коде.
Это способствует написанию более надежного и устойчивого к ошибкам кода.

В Kotlin отказались от разделения для:

* Уменьшения количества boilerplate-кода.
* Избегание нежелательных исключений: Проверяемые исключения в Java часто могут приводить к
  "ловушкам исключений" (exception traps), когда разработчики просто пробрасывают исключения выше по
  стеку вызовов без реальной обработки ошибки.

</details>

<details>
<summary>В чём отличия checked/unchecked исключений</summary>

Checked исключения, это те, которые должны обрабатываться блоком catch или описываться в сигнатуре
метода. Unchecked могут не обрабатываться и не быть описанными.

Unchecked исключения в Java — наследованные от RuntimeException, checked — от Exception (не включая
unchecked).
</details>

<details>
<details>
<summary>Ключевое слово volatile</summary>
Поле не будет кешироваться в каждом потоке (т.е. копироваться в Thread local cache)
Нельзя будет одновременно двум потокам получать значение переменной
Поле доступно нескольким потокам;
</details>

<details>
<summary>Ключевое слово native</summary>
метод с кодом, написанным на другом языке;
</details>

<details>
<summary>Parcelable vs Serializable</summary>

hashCode позволяет определить корзину для поиска элемента, а equals используется для сравнения
ключей элементов в списке внутри корзины и искомого ключа.

</details>

<details>
<summary>Как узнать тип дженерика во время выполнения программы</summary>

При работе с дженериками есть одна очень важная особенность, о которой необходимо помнить. Она
называется “стирание типов” (type erasure).

Ее суть заключается в том, что внутри класса не хранится никакой информации о его типе-параметре.

Эта информация доступна только на этапе компиляции и стирается (становится недоступной) в runtime.
</details>

<details>
<summary>Как реализованы дженерики внутри?</summary>

Дженерики фактически работают лишь на этапе компиляции. При преобразовании в байт код данные о типе
дженерика стираются (type erasure)
</details>

<details>
<summary>String Pool </summary>

<b>String Pool</b> — это специальная область в куче (Heap), используемая для хранения уникальных
строковых
литералов.
Устраняет необходимость создавать множество одинаковых строковых объектов, сокращая тем самым расход
памятии повышая производительность программ.

<b>Принцип работы</b>:
Когда в коде встречается строковый литерал, JVM проверяет наличие такой строки в пуле:

* Если строка уже присутствует в пуле, то возвращается ссылка на эту строку.
* Если строки нет, она создаётся и помещается в пул, после чего возвращается ссылка на новый объект.
* Строки, созданные через конструктор `new String("...")`, не попадают в пул автоматически. Они
  создают новый объект строки в куче вне пула. Однако такие строки можно явно добавить в пул, вызвав
  метод `intern()`.

Подробное описание с картинками: https://topjava.ru/blog/rukovodstvo-po-string-pool-v-java#5

Чуть более краткое описание работы String Pool: https://easyoffer.ru/question/3970
</details>
